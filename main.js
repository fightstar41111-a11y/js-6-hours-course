// =================== 1. Подключение ===================
/*
- index.html
- файл main.js
- тег <script src></script> <----- Где нибудь вконце перед закрывающим тегом body.
- Запуск в liveServer
- команда console.log для вывода информации в консоль браузера
- комментарии
*/

// <--- однострочный комментарий.

/* Многострочный комментарий открывается с помощью (/ и *) и закрывается с помощью (* и /)*/

// ==================== 2. Переменные ================

// let userName = "Марк";
// console.log(userName);

// ==================== 2.1 Типы переменных =================

// Новый стандарт ES6
// let - переменная
// const - константа

// Старый способ ES5
// var - переменная

// let - может менять значение во время работ программы.
// let userName = "Марк";
// console.log(userName);
// userName = "Егор";
// console.log(userName);

// // const - не может менять знаение
// const yearOfBirth = 1980;

/* ---------------------------------*/
// При объявлении константы мы сразу же должны записать в нее то значение, которое она должна содержать.

/*let name, age;

name = "Yurij";

const profession;

profession = "Js developer"; */

// ------- То что написано выше - не сработает, т.к мы сразу же не объявили константу.

// var - старый фортма объявления перемменной.
// В отличие от let и const имеет функциональную область видимости, а не блочную.
// Не рекомендуется к использованию.
// Может менять значение во время работы программы.

// var city = "Moscow";
// city = "Minsk";
// city = "Kiev";

// console.log(city);

// То есть var имеет видимость внутри функции, а let и const внутри блока кода.

// function sum() {
//   var userName = "Yurij";
// }
// Эта переменная name будет существовать только внутри этой функии, т.е за ее пределами она существовать не будет.

// console.log(userName);
//   Если мы ее попытаемся вызвать за пределами функции - В девтулс мы ее не увидим
// Но внутри функции она есть. И если мы вызовем функцию, тогда мы ее увидим. Пример:
// function sum() {
//   var userName = "Yurij";
//   console.log(userName);
// }
// sum();
// Это была функциональная область видимости.

// А есть еще область видимости внутри блока кода.

// Блок кода объявляется фигурными скобками.
// {
//   let userName = "Bob";
//   console.log(userName);
// }
// Вот так в девтулс выведется Боб.

// А вот так -
// {
//   let userName = "Bob";
//   console.log(userName);
// }

// console.log(userName);

// В devtools покажет ошибку.

// С var такого не произойдет. var имеет глобальную область видимомти. Пример:
// {
//   let userName = "Bob";
//   //   console.log(userName);

//   var someNumber = 10;
//   console.log(someNumber);
// }

// // console.log(userName);
// console.log(someNumber);

// var выведется и в блоке кода и за его пределами.

// По умолчанию используем const, когда понимаем что она значение не меняет.
// Когда явно понятно, что переменная будет менять свое значение, тогда используем let

// -------------------2.2 Типы данных----------------------

// let userName = "Марк";
// Строка (текст) (Одно слово, фраза, предложение абзац, хоть целая книга)

// let age = 30;
// Число

// console.log(30);
// console.log("30");

// let isMarried = true;
// Логическое значение true/false

// Динамическая типизация
// let someVariable = "Some value";
// Сейчас someVariable типа Sting
// someVariable = 50;
// Сейчас someVariable типа Number
// someVariable = true;
// Сейчас someVariable типа Boolean

// Плохой пример нейминга
// let u = "Bob";
// console.log(u);

// Хороший пример нейминга
// let userName = "James";
// console.log(userName);

// Значение null - означает "ничего", "пусто", или "значение неизвестно"
// let age = null;
// Пример:
// let age = 32;
// age = null; - обнуляем значение ( в данном случае 32)

// Значение undefined - означает что "значение не было происвоено или оно не определенно"
// Если переменная объявлена, но ей не присвоено никакого значения, то ее значением будет undefined
// let newVariable; // будет undefined
// let userName; //undefined
// console.log(userName);

// Если мы хотим обнулить перемную
// let someName = "James";
// someName = undefined; //Так не делают
// someName = null; //Делают так

// Объекты
// Массивы

// Оператор typeof
// const someName = "Bod";
// console.log(typeof someName); //В девтулс увидим string - строка, потому что Боб это строка.

// const someName = 33;
// console.log(typeof someName); //В девтулс увидим number потому что 33 это число.

// const someName = true;
// console.log(typeof someName); //В девтулс увидим boolean потому что true это логический тип значения.

// BigInt -тоже тип значения - это встроенный объект, который позволяет нам создавать большиие числа.
// Максимальное число, которое мы можем использовать в Js типа number мы можем получить обратившись к объекту типа number и его св-ву MAX_SAFE_INTEGER.

// console.log(Number.MAX_SAFE_INTEGER);
// Devlools выведет максимальное целое число  9007199254740991

// А если мы будем работать с этим числом и делать что -то больше, чем это число, то не сработает.
// И в таком случае нам нужен BigInt.Вконце числа нужно просто дописать n и тогда код сработает.
//  Пример:

// console.log(90071992547409943534563654645n);

// Symbol

// Используется для того, что бы создать уникальные значения, для идентификаторов для имен св-в в объектах.
// Символ - это уникальное примитивное значение.
// Позволяет добавить уникальное св-во к объекту, с уверенностью что он не перезапишет никакое др св-во.

// Итого типы данных,которые есть в Js:

// Числа number
// Строки String
// Булевой тип данных Boolean
// null
// undefined
// Объекты Object
// Массивы

// Symbol
// BigInt

// ********** 3. Операторы сравнения и условия***********

/*
Операторы сравнения
>, <, >=, <= - больше, меньше, больше либо равно, меньше либо равно.
== - нестрогое сравнение
=== - строгое сравнение
!= - нестрогое неравенство
!== - трогое неравенство
*/

// console.log(10 > 5); // true
// console.log(10 < 5); // false

// // let result = 10 > 5; // true
// // console.log(result);

// let result = 10 == 5; // false
// console.log(result);

// console.log("5" == 5); // true
// console.log("5" === 5); // false

//  = - Присвоение - пример
// let number = 5;
// if ((number = 10)) {
//   console.log(1111);
//   console.log(number);
// }

/*
if (условие) {
    // Код который будет выполнен если условие верно
} else {
    // Код который будет выполнен если условие НЕ верно
}
*/

// const time = 12;

// if (time < 12) {
//   console.log("Доброе утро");
// } else {
//   console.log("Добрый день");
// } // Выполнится условие else т.к 12 это не меньше 12. Если бы было 11, то выполнился бы первый блок кода- "Доброе утро"

// Else if

// const time = 20;

// if (time < 12) {
//   console.log("Доброе утро");
// } else if (time >= 12 && time < 18) {
//   console.log("Добрый день");
// } else {
//   console.log("Добрый вечер");
// }

/*
Логические операторы
&& - логическое И
|| - логическое ИЛИ
!true - логическое НЕ
*/

// *********** 4. Тернарный оператор ***********
// Это короткая форма записи условий.

// if (10 < 12) {
//   console.log("Условие верно");
// } else {
//   console.log("Условие НЕ верно");
// }

// (условие) ? (условие верно) : (условие НЕ верно);

// 10 < 12 ? console.log("Условие верно") : console.log("Условие НЕ верно");
// Это тоже самое что и сверху. ? означает что условие верно, тогда выполнится первый блок кода, а : означает else - если условие не верно, то выполнится второй блок кода.

// Также тернарный оператор может возвращать какие-то значения, что бы мы их потом записывали в переменные. Пример:

// let greeting;
// let time = 10;

// if (time < 12) {
//   greeting = "Доброе утро";
// } else {
//   greeting = "Добрый день";
// }
// console.log(greeting);

// Если мы мотим этот же код описать в виде тернарного оператора, пример ни же.

// let time = 10;
// greeting = time < 12 ? "Доброе утро" : "Добрый день";
// console.log(greeting);

//  ************** 5. Конкатенация строк и шаблонные строки ********

/* Конкатенация — это операция склеивания строк (или строк с другими значениями) в одну.

В JavaScript делается через знак +
*/

// let greeting = "Привет, Марк!";
// let howAreYou = " Как твои дела?";

// let sayHi = greeting + howAreYou;

// console.log(sayHi);

// Это пример сложения переменных, в которых есть строки.
// конкатенация "строка" + "строка"

// const userName = "Марк";
// console.log("Привет, " + userName + "! Как твои дела?");

// Шаблонные строки ES6 (Обратные ковычки)
// Шаблонные строки и интерполяция
// const userName = "Марк";
// console.log(`Привет, ${userName}! Как твои дела?`);

// **************Функции********************
// DRY - don't repeat yourself
// Имя функции должно быть глаголом.

// function sayHi() {
//   console.log("Привет, дорогой пользователь!");
// }
// sayHi();

// Запускаем функцию на выполнение через обращение к имени функции, (в данном случае sayHi) и круглые скобки рядом - это ее вызов.

/*
Если нам нужно использовать ее в нескольких местах, то мы можем без проблем вызывать ее сколько угодно раз.  
sayHi();
sayHi();
sayHi();
sayHi();
*/

// Также без проблем можно поменять инфу внутри функции.

// function sayHi() {
//   console.log("Привет, уважаемый пользователь!");
// }
// sayHi();

// 2 способа объявления функции

// // 1. function declaration
// function sayHi() {
//   alert("Привет");
// }

// 2. function expression (Функциональное выражение) - мы описываем функцию и эту функцию записываем в переменную. Пример:

// let sayHi = function () {
//   alert("Привет");
// };

// Фанкшион экспрешион мы можем записать в любую переменную - let (как пример выше), const, var.

// Когда мы объявляем функцию через function declaration - мы можем вызывать эту функцию до того, как она была объявлена в кожде.
//  Т. е Java Script code считывается сверху вниз. Соответственно если мы хотим что-то использовать внутри кода, то мы должны сначала это объявить. Пример:

// console.log(userName);
// let userName = "Bob";

// Или вот пример, мы можем описать нашу функцию sayHi и использовать ее до того, как она объявлена (а можно и после). -

// sayHi();

// function sayHi() {
//   alert("Привет");
// }

// А фанкшион экспрессион, мы вызывем функцию только после того, как она объявлена.

// *************6.1 Параметры и аргументы для функции*********

// const userName = "Марк";
// console.log("Приверт, ${userName}! Как твои дела?");

// function sayHi(userName) {
//   console.log(`Приверт, ${userName}! Как твои дела?`);
// }
// sayHi("Yurij");
// sayHi("Pavel");
// sayHi("Alex");

// Когда мы описываем функцию - function sayHi(name) {
//   console.log("Приверт, ${name}! Как твои дела?");
// } это параметры (name) (в круглых скобках)

//  А когда мы вызываем функцию - sayHi('Yurij') - мы вызываем ее с передачей в нее аргументов. То есть ('Yurij') в данном случае аргумент.

// *************** return************************

// function summ(a, b) {
//   const result = a + b;
//   return result;
// }

// let res = summ(10, 15); // <---- именно сюда (в круглые скобки) функция возвращает значение. т.е 25 "образуется" именно там - let res = 25; и оно потом записывается в переменную res
// console.log(res);

// return -функция завершает свою работу, после того как был встречен return. Пример:

// function summ(a, b) {
//   console.log("Start");
//   const result = a + b;
//   return result;
//   console.log("Finish"); // Здесь финиш никогда не будет достигнут, т.к return уже произошел, результат возвращен и функция завершает свою работу.
// }

// let res = summ(10, 15);
// console.log(res);

// *************** 6.3 Функция как аргументы*****************

//Мы можем сократить этот код, который ниже.

// function summ(a, b) {
//   const result = a + b;
//   return a + b;
// }

// И сделать его таким. Будет выполнено это выражение a + b оно сложится, получится какоето число. И это число сразу будет возвращенно, поэтому можно не создавать переменную result и сразу сделать так-

// function summ(a, b) {
//   return a + b;
// }

// Также мы можем передавать функцию, как аргумент в др функции. Например мы можем сразу в консоль лог передать не переменную, а ФУНКЦИЮ.  Пример:

// function summ(a, b) {
//   return a + b;
// }

// console.log(summ(10, 15)); // передали функцию с аргументами 10 и 15.

// А теперь пример посложнее.
// Запустим функцию summ и передадим в нее 2 аргумента.
// const result = summ(summ(15, 15), summ(20, 20));
// console.log(result);

// Еще один более сложный аргумент, когда функцию мы можем передать в качестве аргумента в др функцию и она будет запущена в др функции. Пример:

// function summ(a, b) {
//   return a + b;
// }

// function doSomething(func) {
//   // и функция doSomething будет принимать в качестве аргумента функцию.
//   let x = 10; // внутри у нее свои внутренние переменные.
//   let y = 15;
//   let result = func(x, y);
//   console.log(result);
// }

// doSomething(summ); // Запускаю функцию doSomething мы передаем в нее summ. Это называется функция callback

// *********** 6.4 Самовызывающаяся функция IIFE************
// ES5

// (function () {
//   console.log("Привет, дорогой пользователь!");
// })(); //Это пример анонимной самовызывающейся функции (ибо у function нет имени. Ну типа нет function sayHi и  тд)

// Еще 1 пример анонимной самовызывающейся функции и запустить ее с передачей в нее аргументов.

// (function summ(a, b) {
//   // Также можно удалить имя функции summ и это сделает функцию анонимной, как в примере выше.
//   console.log(a + b);
// })(10, 15); // В эти круглые скобки мы передаем значение. 10 и 15 это и есть значение.

// Также можно использовать ретерн, что бы функция возвращала это значение. Пример:

// (function () {
//   console.log("Привет, дорогой пользователь!");
// })();

// let res = (function summ(a, b) {
//   // Указываем let res что бы результат (25) не пропал нужно его записать куда -то. ПОэтому создаем переменную let res.
//   return a + b;
// })(10, 15);

// console.log(res);

// ********** 6.5 Стрелочные функции ***************************
// ES6

// function sayHi(userName) {
//   console.log(`Привет, ${userName}! Как твои дела?`);
// } // Это фанкшион декларэйшион.
// sayHi("Марк");

// Далее фанкшион экспрешион.

// const sayHi = function (userName) {
//   console.log(`Привет, ${userName}! Как твои дела?`);
// };
// sayHi("Марк");

// А в стрелочных функциях выглядело бы вот так:
//  1й вариант.

// const SayHi2 = (userName) => {
//   console.log(`Привет, ${userName}! Как твои дела?`);
// };
// SayHi2("Марк");
// Стрелочная функция не имеет своего контекста и она ссылается на тот же контекст на который ссылается и область в которой она была объявлена.

// 2й вариант. Еще более короткий.

// const SayHi2 = (userName) => console.log(`Привет, ${userName}! Как твои дела?`);
// SayHi2("Марк");

// Еще 1 пример для закрепления.

// Это функция
// function summ(a, b) {
//   const result = a + b;
// }

// А это стрелочная функция.

// const summ = (a, b) => {
//   const result = a + b;
//   return result;
// };

// Ее также можно сократить вот так:

// const summ = (a, b) => a + b; // Если тут что - то высчитывается и сразу же возвращается. то можно сократить до такого значния.
// const res = summ(10, 30); // const res для того что бы записать куда то значение.
// console.log(res);

// ************** 7. Массивы *********************

// Это структуры данных.
// Грубо говоря это коллекция. Только мы можем эту коллекцию сделать короче, а не расписывать как на примере ниже.

// const autoBrand1 = "Audi";
// const autoBrand2 = "BMW";
// const autoBrand3 = "Mazda";
// const autoBrand4 = "Toyota";

// // Пример массива
// // Квадратные скобки это либо массив, либо массиво-подобная структура. типа nodeList (массив, просто не полный)

// // const autoBrands = ["Audi", "BMW", "Mazda", "Toyota"];
// // console.log(autoBrands);

// // Если в девтулс при раскрытии стрелочки мы видем - [[Prototype]] : Array(0) это говорит нам о том что это именно чистый массив, а не какая нибудь структура похожая на него. Об этом говорит Array

// // Следующим образом можем вывести в девтулс каждый элемент по индексу (индекс начинается с 0):

// // console.log(autoBrands[0]);
// // console.log(autoBrands[2]);

// // А через length мы можем в консоли увидеть сколько всего элементов внутри массива. Длина массива.
// // console.log(autoBrands.length);

// //  В массивы мы можем записывать любые элементы, числа, логические данные главное что бы они были одного смысла, как пример с машинами.
// // А также мы можем в масиве сделать вложенныйы массив. Пример:

// const autoBrands = ["Audi", 9, "BMW", true, ["Mazda", "Toyota"], 70]; // Заметили в квадратных скобках оказались мазда и тойота? так пишется вложенный массив. Этим способ можно групировать разный тип значений в один массив. Но конечно же этого делать не стоит. Массив должен составлять единую коллекцию по смыслу или значению.
// console.log(autoBrands);

//  *************** 7.1  Методы массивов ***********************

/*
.push(), .pop(), shift(), unshift(), .splice(), .slice(), .forEach(), indexOf(), .includes() и тд.
*/

/*
arr.push(...items) - Добавить элемент в конец массива
arr.pop() - Удалить элемент из конца массива
arr.shift() - Удалить элемент из начала массива
arr.unshift(...items) - Добавить элемент в начало массива
arr.splice([start], [deleteCount, newElements])
*/

// const autoBrands = ["Audi", "BMW", "Mazda", "Toyota"];
// console.log(autoBrands);

// autoBrands.push("Nissan");
// console.log(autoBrands);

// Не смотря на то что,  константа не изменна, мы можем все равно можем добавить Ниссан, т. к она ссылается только на этот массив - ["Audi", "BMW", "Mazda", "Toyota"] с этим массивом мы можем работать конкретно в этом примере, а если бы мы хотели, что бы константа ссылалась на др какой - то массив, то мы получим ошибку. а С этим массивом мы можем работать. Мы можем в него добавлять, вырезать, удалять, главное чтобы он существовал.  И мы можем работать с его элементами внутри как угодно. Грубо говоря конастанта должна сохранять "ссылку" на этот ["Audi", "BMW", "Mazda", "Toyota"] массив. Значение объектов и массивов передаюются по "ссылке" это ньюанс JS.

// let array2 = autoBrands; // так  можно проверить равны ли эти массивы. Получается что array2 ссылается на , который в свою очередь ссылается на этот массив "Audi", "BMW", "Mazda", "Toyota"]; Что бы увидеть равны или нет в девтулс нам нужно в девтулс написать так - array2 == autoBrands и  тогда результат покажется, в нашем случае - true. Т.е когда мы сказали что array2 = autoBrands, а autoBrands ссылается на этот массив ["Audi", "BMW", "Mazda", "Toyota"] в области памяти, получается  array2 ссылается на autoBrands, который ссылается на наш массив. И в итоге получается что array2 ссылается на наш массив.  То есть обе переменные - эррей 2 и утобрендс ссылаются на наш массив. И когда мы их сравниваем равны ли они - да они равны, потому что они ссылаются на 1 и тот же массив.

// А если мы скажем что у нас есть aray2, который равен миссиву (["Audi", "BMW", "Mazda", "Toyota"]) казалось бы такому же как в автобрэендс, то у нас ничего не выйдет, равны массивы не будут потому что мы создали новый массив. Сравнение то идет по ссылкам, и получается что ауто брендс ссылается на один массив в области памяти, а array2 на другой. Не смотря на что массивы похожи, они разные.

// const autoBrands = ["Audi", "BMW", "Mazda", "Toyota"];
// console.log(autoBrands);

// autoBrands.push("Nissan"); // через метод push можем добавялть эллементы в массивы.
// console.log(autoBrands);

// autoBrands.splice(2, 1); //можем удалять эл из массива. Работает таки м способом - первый элемент говорит нам с какого индекса стартовать - мы старутуем в этом примере с индекса 2. То есть указатель становится перед этим индексом. (0,1, (здесь встанет указатель) 2) И удалится Mazda. а цифра 1 это означает сколько элементов мы удалим.
// console.log(autoBrands);

// ******************* Циклы **************************

// Циклы нужны что бы выполнять какую то операцию нное кол-во раз (5,12 и тд) Что бы не вызывать 1 и тот же код 10 раз мы используем циклы. А также для обхода массивов мы используем циклы.

// ПЕРВЫЙ ЭТО ЦИКЛ FOR

// for (let i = 0; i < 10; i++) {
//   console.log(i);
// }
// В круглых скобках мы описываем значение. То есть мы описываем счетчик который булет регулировать цикл. От этого цикла зависит сколько раз наш цикл будет будет работать.

// 1) Первым мы указыаем нчальное значение счетчика (в этом примере естественоо) i = 0. Обычно сччетчик объявляется через переменную с именем i. Можно назвать как угодно, но i считается классикой и более общепринятой.
// 2) Затем мы пишем условие при котом наш счетчик будет работать - пока i меньше 10 цикл будет выполняться. Как только i станет больше или равно 10 цикл остановит свое выполнение и произойдет выход из цикла и программа продолжит работать дальше. 3) И третьим значением мы указываем итерратор , то есть то как будет изменяться наша переменная i после каждой итеррации цикла. У нас она будет увеличиваться на 1. (i++) То есть i после первого цикла станет уже не равен 0, а равен 1, потом после этогр цикла равен 2. и так далее до 9 включительно. т.к 10 это уже не меньше 10, а равно ему. поэтому цикл остановится на 9.

// Давайте запишем в теле циклы (в фигурных скобках) код который будет выполняться каждый раз как цикл будет запускаться.

// console.log("Start"); // просто для наглядноси

// for (let i = 0; i < 10; i++) {
//   console.log(i);
// }

// console.log("Finish"); // просто для наглядноси

// Также мы можем сказать что iне ++, а к примеру увеличивается на 2. Пример:
// console.log("Start");

// for (let i = 0; i < 10; i = i + 2) {
//   console.log(i);
// } // В девтулс увидем значения - 0, 2, 4, 6, 8 и Финиш.

// console.log("Finish");

// *************** 9. Обход массива циклом for *****************

// const autoBrands = ["Audi", "BMW", "Mazda", "Toyota"];

// Что бы вывести каждый эл массива мы ранее обращались неудобным способом - к каждому по отдельности к его индексу. Пример:

// console.log(autoBrands[0]);
// console.log(autoBrands[1]);
// console.log(autoBrands[2]);
// console.log(autoBrands[3]);
// console.log(autoBrands[4]);

// Мы можем использовать цикл for для того чтобы обойти этот массив и сделать более удобный способ. Пример:

// for (i = 0; i < 4; i++) {
//   //   console.log(i); // можно так. Но он выведет только индекс 0-4.
//   console.log(autoBrands[i]); // Но лучше так. потому что мы такми образом можем вывести элементы массива и вместо числа от 0 до 4 мы подставим i. Код короче и удобнее.
// }

// Но что бы не указывать вручную кол-во элементом -  i < 4;  лучше обратиться к массиву autoBrands и указать св-во length(т.к может быть очень много элементов и посчитать вручную будет их сложно) Пример:

// for (i = 0; i < autoBrands.length; i++) {
//   console.log(autoBrands[i]);
// }

// *********** 10. Обход массива циклом for ( of ) **************

// const autoBrands = ["Audi", "BMW", "Mazda", "Toyota"];

// наш массив будет пройден  столько раз сколько в нем эл-в и мы говорим что в момент прохождения массива мы будем создавать  переменную item. Т.е каждый раз переменная item будет равна одно му из эл-в массива который мы обходим аутобрэндс.

// for (let item of autoBrands) {
//   console.log(item);
// }

// Т.е мы говорим - для массива autoBrands  обходим его и на каждой итеррации каждый его эл-т массива записываем в item.

// Тоесть каждый элемент будет поочереди записан в переменную item и в каждой итеррации мы к ней обращаемся и выводим.

// ******** 11. Обход методом forEach()*****

// const autoBrands = ["Audi", "BMW", "Mazda", "Toyota"];

// autoBrands.forEach(function (brand, i) {
//   console.log(`${brand} => ${i}`);
// }); // brand - это тот же item. i-index.

// Также можно описать эту функцию где-то в др месте. Пример:

// autoBrands.forEach(printBrand);

// function printBrand(brand, i) {
//   console.log(`${brand} => ${i}`);
// }
// Функция  printBrand будет использоваться как функция обработчик для каждого элемента массива.

// Также можно описать в виде стрелочной функции.

// autoBrands.forEach((brand, i) => {
//   console.log(`${brand} => ${i}`);
// });

// Еще мы можем ее сократить до такой записи( убрать фиг скобки)

// autoBrands.forEach((brand, i) => console.log(`${brand} => ${i}`));

// ************ 12. Объекты ****************

// Это структура данных, кот ползвоялет нам организовывать данные.

// Свойство объектов

// Можно описать так
// let userName = "Марк";
// let age = "30";
// let isMarried = false;

// А можно объединить их в объект

// const person = {
//   userName: "Марк",
//   age: 30,
//   isMarried: false,
// };

// console.log(person);

// Если в девтулс мы видим фигерные скобки и двоеточие - то мы имеем дело с объектом. - {userName: 'Марк', age: 30, isMarried: false}

// Что бы нам обратиться отдельно к св-вам объекта (вывести их), нужно обращаться через точку, и также мы указываем имя объекта.
// console.log(person.userName);

// Есть еще 1 способ - нужно написать его в квадратных скобках.
// console.log(person["age"]);
// последний способ полезен если имя св-вф к которому мы хотим обратиться находится в переменной. Пример:

// const person = {
//   userName: "Марк",
//   age: 30,
//   isMarried: false,
//   profession: "Desiner",
// };

// let propertyName = "profession";
// console.log(person[propertyName]);

// Несмотря на то, что объект у нас уже описан, мы можем добавить к нему какие либо св-ва. Для этого нам нужно обратиться к этому объекту (в данном случае по переменной персон) и создать новое св-во у объекта. пример:

// person.profession = "JS developer";
// console.log(person);

// А если мы хотим удалить какое-либо значение из объекта, то мы используем delete.
// delete person.age;
// console.log(person);

// ***************** 13 Методы в объектах ***********************

// const person = {
//   userName: "Марк",
//   age: 30,
//   isMarried: false,
//   sayHi: function () {
//     console.log("Привет!");
//   },
// };

// Таким образом св-во объекта в которое записана функция называается методом объекта.
//  userName: "Марк",
//   age: 30,
//   isMarried: false,  <------ Это св-во

// sayHi: function () {  <------ А это метод.
//     console.log("Привет!");
//   },

// person.sayHi(); // <---  вызываем объект, а круглыми скобками запускам метод.

// Методы мы можем добавлять также как и св-ва через точку. Допустим если бы метода у нас изначально не было. Мы бы добавили его так -

// const person = {
//   userName: "Марк",
//   age: 30,
//   isMarried: false,
// };

// person.sayHi = function () {
//   console.log("Привет!");
// };

// person.sayHi(); // Запускаем - проверяем.

// Также когда мы объявляем метод имы можем сказать (т.к как это функция) что она будет принимать в себя какие то определенные значения и работать с ними. Пример:

// person.sayHi = function (name) {
//   console.log(`Привет, ${name}!`);
// };

// person.sayHi("Юрий"); // <---- передаем Юрий.

// Также можно описать этот параметр в методе. Сразу при описании объекта. Пример:

// const person = {
//   userName: "Марк",
//   age: 30,
//   isMarried: false,
//   sayHi: function (name) {
//     console.log(`Привет, ${name}!`);
//   },
// };

// person.sayHi("Юрий");

// ********* 14. Ключевое слово this ***********************
// Ключевое слово this внутри метода объекта ссылается на  объект.

// К примеру некий Персона Марк хочет поздороватьс с Юрием. Но нам следует помнить негласное правило правило dont reapet yourself(не повторяться) -

// const person = {
//   userName: "Марк",
//   age: 30,
//   isMarried: false,
//   sayHi: function (name) {
//     console.log(this);
//     console.log(`Привет, ${name}! Меня зовут ${this.userName}.`);
//   }, // this ссылается и так ссылается на этот объект (person), поэтому в скобках мы пишет не персон, а this.
// };

// person.sayHi("Юрий");

//  ******* 15. Объекты обход циклом for in (не путать с for of)
